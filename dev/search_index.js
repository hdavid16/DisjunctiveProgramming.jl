var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [DisjunctiveProgramming]\nOrder   = [:macro, :function, :type]","category":"page"},{"location":"api/#DisjunctiveProgramming.@disjunction-Tuple{Any, Vararg{Any}}","page":"API","title":"DisjunctiveProgramming.@disjunction","text":"@disjunction(model, expr, kw_args...)\n\nAdd a disjunction described by the expression expr,  which must be a Vector of LogicalVariableRefs.\n\n@disjunction(model, ref[i=..., j=..., ...], expr, kw_args...)\n\nAdd a group of disjunction described by the expression expr parameterized by i, j, ..., which must be a Vector of LogicalVariableRefs. \n\nIn both of the above calls, a Disjunct tag can be added to create  nested disjunctions.\n\nThe recognized keyword arguments in kw_args are the following:\n\nbase_name: Sets the name prefix used to generate constraint names.    It corresponds to the constraint name for scalar constraints, otherwise,    the constraint names are set to base_name[...] for each index ...        of the axes axes.\ncontainer: Specify the container type.\nexactly1: Specify a Bool whether a constraint should be added to   only allow selecting one disjunct in the disjunction.\n\nTo create disjunctions without macros, see disjunction.\n\n\n\n\n\n","category":"macro"},{"location":"api/#DisjunctiveProgramming.@disjunctions-Tuple{Any, Any}","page":"API","title":"DisjunctiveProgramming.@disjunctions","text":"@disjunctions(model, args...)\n\nAdds groups of disjunctions at once, in the same fashion as the @disjunction macro.\n\nThe model must be the first argument, and multiple disjunctions can be added on multiple  lines wrapped in a begin ... end block.\n\nThe macro returns a tuple containing the disjunctions that were defined.\n\nExample\n\njulia model = GDPModel(); @variable(model, w); @variable(model, x); @variable(model, Y[1:4], LogicalVariable); @constraint(model, [i=1:2], w == i, Disjunct(Y[i])); @constraint(model, [i=3:4], x == i, Disjunct(Y[i])); @disjunctions(model, begin     [Y[1], Y[2]]     [Y[3], Y[4]] end);`\n\n\n\n\n\n","category":"macro"},{"location":"api/#Base.getindex-Tuple{ReferenceMap, DisjunctConstraintRef}","page":"API","title":"Base.getindex","text":"Base.getindex(map::GenericReferenceMap, cref::DisjunctConstraintRef)\n\n...\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{ReferenceMap, DisjunctionRef}","page":"API","title":"Base.getindex","text":"Base.getindex(map::GenericReferenceMap, cref::DisjunctionRef)\n\n...\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{ReferenceMap, LogicalConstraintRef}","page":"API","title":"Base.getindex","text":"Base.getindex(map::GenericReferenceMap, cref::LogicalConstraintRef)\n\n...\n\n\n\n\n\n","category":"method"},{"location":"api/#DisjunctiveProgramming.GDPModel-Tuple","page":"API","title":"DisjunctiveProgramming.GDPModel","text":"GDPModel([optimizer]; [kwargs...])::Model\n\nThe core model object for building general disjunction programming models.\n\n\n\n\n\n","category":"method"},{"location":"api/#DisjunctiveProgramming.disjunction","page":"API","title":"DisjunctiveProgramming.disjunction","text":"disjunction(\n    model::Model, \n    disjunct_indicators::Vector{LogicalVariableRef},\n    [nested_tag::Disjunct],\n    [name::String = \"\"];\n    [exactly1::Bool = true]\n)\n\nCreate a disjunction comprised of disjuncts with indicator variables disjunct_indicators  and add it to model. For nested disjunctions, the nested_tag is required to indicate  which disjunct it will be part of in the parent disjunction. By default, exactly1 adds  a constraint of the form @constraint(model, disjunct_indicators in Exactly(1)) only  allowing one of the disjuncts to be selected; this is required for certain reformulations like  Hull. For nested disjunctions, exactly1 creates a constraint of the form @constraint(model, disjunct_indicators in Exactly(nested_tag.indicator)).  To conveniently generate many disjunctions at once, see @disjunction  and @disjunctions.\n\n\n\n\n\n","category":"function"},{"location":"api/#DisjunctiveProgramming.gdp_data-Tuple{Model}","page":"API","title":"DisjunctiveProgramming.gdp_data","text":"gdp_data(model::Model)::GDPData\n\nExtract the GDPData from a GDPModel.\n\n\n\n\n\n","category":"method"},{"location":"api/#DisjunctiveProgramming.is_gdp_model-Tuple{Model}","page":"API","title":"DisjunctiveProgramming.is_gdp_model","text":"is_gdp_model(model::Model)::Bool\n\nReturn if model was created via the GDPModel constructor.\n\n\n\n\n\n","category":"method"},{"location":"api/#DisjunctiveProgramming.reformulate_disjunct_constraint-Tuple{Model, Disjunction, VariableRef, AbstractReformulationMethod}","page":"API","title":"DisjunctiveProgramming.reformulate_disjunct_constraint","text":"reformulate_disjunct_constraint(\n    model::JuMP.Model,  \n    con::JuMP.AbstractConstraint, \n    bvref::JuMP.VariableRef,\n    method::AbstractReformulationMethod\n)\n\nExtension point for reformulation method method to reformulate disjunction constraint con over each  constraint. If method needs to specify how to reformulate the entire disjunction, see  reformulate_disjunction.\n\n\n\n\n\n","category":"method"},{"location":"api/#DisjunctiveProgramming.reformulate_disjunction-Tuple{Model, Disjunction, AbstractReformulationMethod}","page":"API","title":"DisjunctiveProgramming.reformulate_disjunction","text":"reformulate_disjunction(\n    model::Model, \n    disj::Disjunction,\n    method::AbstractReformulationMethod\n) where {T<:Disjunction}\n\nReformulate a disjunction using the specified method. Current reformulation methods include BigM, Hull, and Indicator. This method can be extended for other reformulation techniques.\n\nThe disj field is the ConstraintData object for the disjunction, stored in the  disjunctions field of the GDPData object.\n\n\n\n\n\n","category":"method"},{"location":"api/#DisjunctiveProgramming.reformulate_model-Tuple{Model, AbstractSolutionMethod}","page":"API","title":"DisjunctiveProgramming.reformulate_model","text":"reformulate_model(model::Model, method::AbstractSolutionMethod)\n\nReformulate a GDPModel using the specified method. Prior to reformulation, all previous reformulation variables and constraints are deleted.\n\n\n\n\n\n","category":"method"},{"location":"api/#DisjunctiveProgramming.requires_exactly1-Tuple{AbstractReformulationMethod}","page":"API","title":"DisjunctiveProgramming.requires_exactly1","text":"requires_exactly1(method::AbstractReformulationMethod)\n\nReturn a Bool whether method requires that Exactly 1 disjunct be selected  as true for each disjunction. For new reformulation method types, this should be  extended to return true if such a constraint is required (defaults to false otherwise).\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.add_constraint","page":"API","title":"JuMP.add_constraint","text":"JuMP.add_constraint(\n    model::Model,\n    con::_DisjunctConstraint,\n    name::String = \"\"\n)::DisjunctConstraintRef\n\nExtend JuMP.add_constraint to add a Disjunct to a GDPModel.  The constraint is added to the GDPData in the .ext dictionary of the GDPModel.\n\n\n\n\n\n","category":"function"},{"location":"api/#JuMP.add_constraint-Union{Tuple{S}, Tuple{F}, Tuple{Model, ScalarConstraint{F, S}}, Tuple{Model, ScalarConstraint{F, S}, String}} where {F<:Union{LogicalVariableRef, GenericNonlinearExpr{LogicalVariableRef}}, S<:IsTrue}","page":"API","title":"JuMP.add_constraint","text":"function JuMP.add_constraint(\n    model::Model,\n    c::ScalarConstraint{<:F, S},\n    name::String = \"\"\n) where {F <: Union{LogicalVariableRef, _LogicalExpr}, S}\n\nExtend JuMP.add_constraint to allow creating logical proposition constraints  for a GDPModel with the @constraint macro.\n\nfunction JuMP.add_constraint(\n    model::Model,\n    c::VectorConstraint{<:F, S, Shape},\n    name::String = \"\"\n) where {F <: Union{Number, LogicalVariableRef, _LogicalExpr}, S, Shape}\n\nExtend JuMP.add_constraint to allow creating logical cardinality constraints for a GDPModel with the @constraint macro.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.add_variable","page":"API","title":"JuMP.add_variable","text":"JuMP.add_variable(model::Model, v::LogicalVariable, \n                  name::String = \"\")::LogicalVariableRef\n\nExtend JuMP.add_variable for LogicalVariables. This  helps enable @variable(model, [var_expr], Logical).\n\n\n\n\n\n","category":"function"},{"location":"api/#JuMP.build_constraint-Tuple{Function, Any, MathOptInterface.AbstractScalarSet, Disjunct}","page":"API","title":"JuMP.build_constraint","text":"JuMP.build_constraint(\n    _error::Function, \n    func, \n    set::_MOI.AbstractScalarSet,\n    tag::Disjunct\n)::_DisjunctConstraint\n\nExtend JuMP.build_constraint to add constraints to disjuncts. This in  combination with JuMP.add_constraint enables the use of  @constraint(model, [name], constr_expr, tag), where tag is a Disjunct(::Type{LogicalVariableRef}). The user must specify the  LogicalVariable to use as the indicator for the _DisjunctConstraint being created.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.build_constraint-Tuple{Function, Any, MathOptInterface.Nonnegatives, Disjunct}","page":"API","title":"JuMP.build_constraint","text":"JuMP.build_constraint(\n    _error::Function, \n    func, \n    set::MathOptInterface.Nonnegatives,\n    tag::Disjunct\n)::_DisjunctConstraint\n\nExtend JuMP.build_constraint to add VectorConstraints to disjuncts.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.build_constraint-Tuple{Function, Any, MathOptInterface.Nonpositives, Disjunct}","page":"API","title":"JuMP.build_constraint","text":"JuMP.build_constraint(\n    _error::Function, \n    func, \n    set::MathOptInterface.Nonpositives,\n    tag::Disjunct\n)::_DisjunctConstraint\n\nExtend JuMP.build_constraint to add VectorConstraints to disjuncts.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.build_constraint-Tuple{Function, Any, MathOptInterface.Zeros, Disjunct}","page":"API","title":"JuMP.build_constraint","text":"JuMP.build_constraint(\n    _error::Function, \n    func, \n    set::MathOptInterface.Zeros,\n    tag::Disjunct\n)::_DisjunctConstraint\n\nExtend JuMP.build_constraint to add VectorConstraints to disjuncts.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.build_constraint-Tuple{Function, Any, Nonnegatives, Disjunct}","page":"API","title":"JuMP.build_constraint","text":"JuMP.build_constraint(\n    _error::Function, \n    func, \n    set::Nonnegatives,\n    tag::Disjunct\n)::_DisjunctConstraint\n\nExtend JuMP.build_constraint to add VectorConstraints to disjuncts.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.build_constraint-Tuple{Function, Any, Nonpositives, Disjunct}","page":"API","title":"JuMP.build_constraint","text":"JuMP.build_constraint(\n    _error::Function, \n    func, \n    set::Nonpositives,\n    tag::Disjunct\n)::_DisjunctConstraint\n\nExtend JuMP.build_constraint to add VectorConstraints to disjuncts.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.build_constraint-Tuple{Function, Any, Zeros, Disjunct}","page":"API","title":"JuMP.build_constraint","text":"JuMP.build_constraint(\n    _error::Function, \n    func, \n    set::Zeros,\n    tag::Disjunct\n)::_DisjunctConstraint\n\nExtend JuMP.build_constraint to add VectorConstraints to disjuncts.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.build_constraint-Union{Tuple{S}, Tuple{T}, Tuple{Function, AbstractVector{T}, S}} where {T<:LogicalVariableRef, S<:Union{AtLeast, AtMost, Exactly}}","page":"API","title":"JuMP.build_constraint","text":"function JuMP.build_constraint(\n    _error::Function, \n    func::AbstractVector{T},\n    set::S\n) where {T <: Union{LogicalVariableRef, _LogicalExpr}, S <: Union{Exactly, AtLeast, AtMost}}\n\nExtend JuMP.build_constraint to add logical cardinality constraints to a GDPModel.  This in combination with JuMP.add_constraint enables the use of  @constraint(model, [name], logical_expr in set), where set can be either of the following cardinality sets: AtLeast(n), AtMost(n), or Exactly(n).\n\nExample\n\nTo select exactly 1 logical variable Y to be true, do  (the same can be done with AtLeast(n) and AtMost(n)):\n\nusing DisjunctiveProgramming\nmodel = GDPModel();\n@variable(model, Y[i = 1:2], LogicalVariable);\n@constraint(model, [Y[1], Y[2]] in Exactly(1));\n\nJuMP.build_constraint(\n    _error::Function, \n    func::_LogicalExpr,\n    set::IsTrue\n)\n\nExtend JuMP.build_constraint to add logical propositional constraints to a GDPModel.  This in combination with JuMP.add_constraint enables the use of  @constraint(model, [name], logical_expr in IsTrue()) to define a Boolean expression that must either be true or false.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.build_variable-Tuple{Function, VariableInfo, Type{LogicalVariable}}","page":"API","title":"JuMP.build_variable","text":"JuMP.build_variable(_error::Function, info::VariableInfo, \n                    ::Type{LogicalVariable})::LogicalVariable\n\nExtend JuMP.build_variable to work with logical variables. This in  combination with JuMP.add_variable enables the use of  @variable(model, [var_expr], LogicalVariable).\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.constraint_object-Tuple{DisjunctConstraintRef}","page":"API","title":"JuMP.constraint_object","text":"JuMP.constraint_object(cref::DisjunctConstraintRef)\n\nReturn the underlying constraint data for the constraint      referenced by cref.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.constraint_object-Tuple{DisjunctionRef}","page":"API","title":"JuMP.constraint_object","text":"JuMP.constraint_object(cref::DisjunctionRef)\n\nReturn the underlying constraint data for the constraint      referenced by cref.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.constraint_object-Tuple{LogicalConstraintRef}","page":"API","title":"JuMP.constraint_object","text":"JuMP.constraint_object(cref::LogicalConstraintRef)\n\nReturn the underlying constraint data for the constraint      referenced by cref.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.delete-Tuple{Model, DisjunctConstraintRef}","page":"API","title":"JuMP.delete","text":"JuMP.delete(model::Model, cref::DisjunctConstraintRef)\n\nDelete a disjunct constraint from the GDP model.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.delete-Tuple{Model, DisjunctionRef}","page":"API","title":"JuMP.delete","text":"JuMP.delete(model::Model, cref::DisjunctionRef)\n\nDelete a disjunction constraint from the GDP model.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.delete-Tuple{Model, LogicalConstraintRef}","page":"API","title":"JuMP.delete","text":"JuMP.delete(model::Model, cref::LogicalConstraintRef)\n\nDelete a logical constraint from the GDP model.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.delete-Tuple{Model, LogicalVariableRef}","page":"API","title":"JuMP.delete","text":"JuMP.delete(model::Model, vref::LogicalVariableRef)\n\nDelete the logical variable associated with vref from the GDP model.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.fix-Tuple{LogicalVariableRef, Bool}","page":"API","title":"JuMP.fix","text":"JuMP.fix(vref::LogicalVariableRef, value::Bool)\n\nFix a logical variable to a value. Update the fixing constraint if one exists, otherwise create a new one.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.fix_value-Tuple{LogicalVariableRef}","page":"API","title":"JuMP.fix_value","text":"JuMP.fix_value(vref::LogicalVariableRef)\n\nReturn the value to which a logical variable is fixed.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.index-Tuple{DisjunctConstraintRef}","page":"API","title":"JuMP.index","text":"JuMP.index(cref::DisjunctConstraintRef)\n\nReturn the index constraint associated with cref.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.index-Tuple{DisjunctionRef}","page":"API","title":"JuMP.index","text":"JuMP.index(cref::DisjunctionRef)\n\nReturn the index constraint associated with cref.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.index-Tuple{LogicalConstraintRef}","page":"API","title":"JuMP.index","text":"JuMP.index(cref::LogicalConstraintRef)\n\nReturn the index constraint associated with cref.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.index-Tuple{LogicalVariableRef}","page":"API","title":"JuMP.index","text":"JuMP.index(vref::LogicalVariableRef)\n\nReturn the index of logical variable that associated with vref.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.is_fixed-Tuple{LogicalVariableRef}","page":"API","title":"JuMP.is_fixed","text":"JuMP.is_fixed(vref::LogicalVariableRef)\n\nReturn true if vref is a fixed variable. If     true, the fixed value can be queried with     fix_value.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.is_valid-Tuple{Model, DisjunctConstraintRef}","page":"API","title":"JuMP.is_valid","text":"JuMP.is_valid(model::Model, cref::DisjunctConstraintRef)\n\nReturn true if cref refers to a valid constraint in the GDP model.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.is_valid-Tuple{Model, DisjunctionRef}","page":"API","title":"JuMP.is_valid","text":"JuMP.is_valid(model::Model, cref::DisjunctionRef)\n\nReturn true if cref refers to a valid constraint in the GDP model.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.is_valid-Tuple{Model, LogicalConstraintRef}","page":"API","title":"JuMP.is_valid","text":"JuMP.is_valid(model::Model, cref::LogicalConstraintRef)\n\nReturn true if cref refers to a valid constraint in the GDP model.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.is_valid-Tuple{Model, LogicalVariableRef}","page":"API","title":"JuMP.is_valid","text":"JuMP.is_valid(model::Model, vref::LogicalVariableRef)\n\nReturn true if vref refers to a valid logical variable in GDP model.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.isequal_canonical-Tuple{LogicalVariableRef, LogicalVariableRef}","page":"API","title":"JuMP.isequal_canonical","text":"JuMP.isequal_canonical(v::LogicalVariableRef, w::LogicalVariableRef)\n\nReturn true if v and w refer to the same logical variable in the same GDP model.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.name-Tuple{DisjunctConstraintRef}","page":"API","title":"JuMP.name","text":"JuMP.name(cref::DisjunctConstraintRef)\n\nGet a constraint's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.name-Tuple{DisjunctionRef}","page":"API","title":"JuMP.name","text":"JuMP.name(cref::DisjunctionRef)\n\nGet a constraint's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.name-Tuple{LogicalConstraintRef}","page":"API","title":"JuMP.name","text":"JuMP.name(cref::LogicalConstraintRef)\n\nGet a constraint's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.name-Tuple{LogicalVariableRef}","page":"API","title":"JuMP.name","text":"JuMP.name(vref::LogicalVariableRef)\n\nGet a logical variable's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.owner_model-Tuple{DisjunctConstraintRef}","page":"API","title":"JuMP.owner_model","text":"JuMP.owner_model(cref::DisjunctConstraintRef)\n\nReturn the model to which cref belongs.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.owner_model-Tuple{DisjunctionRef}","page":"API","title":"JuMP.owner_model","text":"JuMP.owner_model(cref::DisjunctionRef)\n\nReturn the model to which cref belongs.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.owner_model-Tuple{LogicalConstraintRef}","page":"API","title":"JuMP.owner_model","text":"JuMP.owner_model(cref::LogicalConstraintRef)\n\nReturn the model to which cref belongs.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.owner_model-Tuple{LogicalVariableRef}","page":"API","title":"JuMP.owner_model","text":"JuMP.owner_model(vref::LogicalVariableRef)\n\nReturn the GDP model to which vref belongs.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.set_name-Tuple{DisjunctConstraintRef, String}","page":"API","title":"JuMP.set_name","text":"JuMP.set_name(cref::DisjunctConstraintRef, name::String)\n\nSet a constraint's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.set_name-Tuple{DisjunctionRef, String}","page":"API","title":"JuMP.set_name","text":"JuMP.set_name(cref::DisjunctionRef, name::String)\n\nSet a constraint's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.set_name-Tuple{LogicalConstraintRef, String}","page":"API","title":"JuMP.set_name","text":"JuMP.set_name(cref::LogicalConstraintRef, name::String)\n\nSet a constraint's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.set_name-Tuple{LogicalVariableRef, String}","page":"API","title":"JuMP.set_name","text":"JuMP.set_name(vref::LogicalVariableRef, name::String)\n\nSet a logical variable's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.set_start_value-Tuple{LogicalVariableRef, Union{Nothing, Bool}}","page":"API","title":"JuMP.set_start_value","text":"JuMP.set_start_value(vref::LogicalVariableRef, value::Union{Nothing, Bool})\n\nSet the start value of the logical variable vref.\n\nPass nothing to unset the start value.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.start_value-Tuple{LogicalVariableRef}","page":"API","title":"JuMP.start_value","text":"JuMP.start_value(vref::LogicalVariableRef)\n\nReturn the start value of the logical variable vref.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.unfix-Tuple{LogicalVariableRef}","page":"API","title":"JuMP.unfix","text":"JuMP.unfix(vref::LogicalVariableRef)\n\nDelete the fixed value of a logical variable.\n\n\n\n\n\n","category":"method"},{"location":"api/#DisjunctiveProgramming.AbstractReformulationMethod","page":"API","title":"DisjunctiveProgramming.AbstractReformulationMethod","text":"AbstractReformulationMethod <: AbstractSolutionMethod\n\nAn abstract type for reformulation approaches used to solve GDPModels.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.AbstractSolutionMethod","page":"API","title":"DisjunctiveProgramming.AbstractSolutionMethod","text":"AbstractSolutionMethod\n\nAn abstract type for solution methods used to solve GDPModels.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.AtLeast","page":"API","title":"DisjunctiveProgramming.AtLeast","text":"AtLeast{T<:Union{Int,LogicalVariableRef}} <: AbstractVectorSet\n\nConvenient alias for using _MOIAtLeast.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.AtMost","page":"API","title":"DisjunctiveProgramming.AtMost","text":"AtMost{T<:Union{Int,LogicalVariableRef}} <: AbstractVectorSet\n\nConvenient alias for using _MOIAtMost.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.BigM","page":"API","title":"DisjunctiveProgramming.BigM","text":"BigM <: AbstractReformulationMethod\n\nA type for using the big-M reformulation approach for disjunctive constraints.\n\nFields\n\nvalue::Float64: Big-M value (default = 1e9).\ntight::Bool: Attempt to tighten the Big-M value (default = true)?\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.ConstraintData","page":"API","title":"DisjunctiveProgramming.ConstraintData","text":"ConstraintData{C <: AbstractConstraint}\n\nA type for storing constraint objects in GDPData and any meta-data  they possess.\n\nFields\n\nconstraint::C: The constraint.\nname::String: The name of the proposition.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.Disjunct","page":"API","title":"DisjunctiveProgramming.Disjunct","text":"Disjunct\n\nUsed as a tag for constraints that will be used in disjunctions. This is done via  the following syntax:\n\njulia> @constraint(model, [constr_expr], Disjunct)\n\njulia> @constraint(model, [constr_expr], Disjunct(lvref))\n\nwhere lvref is a LogicalVariableRef that will ultimately be associated  with the disjunct the constraint is added to. If no lvref is given, then one is  generated when the disjunction is created.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.DisjunctConstraintIndex","page":"API","title":"DisjunctiveProgramming.DisjunctConstraintIndex","text":"DisjunctConstraintIndex\n\nA type for storing the index of a Disjunct.\n\nFields\n\nvalue::Int64: The index value.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.DisjunctConstraintRef","page":"API","title":"DisjunctiveProgramming.DisjunctConstraintRef","text":"DisjunctConstraintRef\n\nA type for looking up disjunctive constraints.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.Disjunction","page":"API","title":"DisjunctiveProgramming.Disjunction","text":"Disjunction <: AbstractConstraint\n\nA type for a disjunctive constraint that is comprised of a collection of  disjuncts of indicated by a unique LogicalVariableRef.\n\nFields\n\nindicators::Vector{LogicalVariableRef}: The references to the logical variables \n\n(indicators) that uniquely identify each disjunct in the disjunction.\n\nnested::Bool: Is this disjunction nested within another disjunction?\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.DisjunctionIndex","page":"API","title":"DisjunctiveProgramming.DisjunctionIndex","text":"DisjunctionIndex\n\nA type for storing the index of a Disjunction.\n\nFields\n\nvalue::Int64: The index value.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.DisjunctionRef","page":"API","title":"DisjunctiveProgramming.DisjunctionRef","text":"DisjunctionRef\n\nA type for looking up disjunctive constraints.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.Exactly","page":"API","title":"DisjunctiveProgramming.Exactly","text":"Exactly <: AbstractVectorSet\n\nConvenient alias for using _MOIExactly.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.GDPData","page":"API","title":"DisjunctiveProgramming.GDPData","text":"GDPData\n\nThe core type for storing information in a GDPModel.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.Hull","page":"API","title":"DisjunctiveProgramming.Hull","text":"Hull <: AbstractReformulationMethod\n\nA type for using the convex hull reformulation approach for disjunctive  constraints.\n\nFields\n\nvalue::Float64: epsilon value for nonlinear hull reformulations (default = 1e-6).\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.Indicator","page":"API","title":"DisjunctiveProgramming.Indicator","text":"Indicator <: AbstractReformulationMethod\n\nA type for using indicator constraint approach for linear disjunctive constraints.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.LogicalConstraintIndex","page":"API","title":"DisjunctiveProgramming.LogicalConstraintIndex","text":"LogicalConstraintIndex\n\nA type for storing the index of a logical constraint.\n\nFields\n\nvalue::Int64: The index value.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.LogicalConstraintRef","page":"API","title":"DisjunctiveProgramming.LogicalConstraintRef","text":"LogicalConstraintRef\n\nA type for looking up logical constraints.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.LogicalVariable","page":"API","title":"DisjunctiveProgramming.LogicalVariable","text":"LogicalVariable <: AbstractVariable\n\nA variable type the logical variables associated with disjuncts in a Disjunction.\n\nFields\n\nfix_value::Union{Nothing, Bool}: A fixed boolean value if there is one.\nstart_value::Union{Nothing, Bool}: An initial guess if there is one.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.LogicalVariableData","page":"API","title":"DisjunctiveProgramming.LogicalVariableData","text":"LogicalVariableData\n\nA type for storing LogicalVariables and any meta-data they  possess.\n\nFields\n\nvariable::LogicalVariable: The variable object.\nname::String: The name of the variable.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.LogicalVariableIndex","page":"API","title":"DisjunctiveProgramming.LogicalVariableIndex","text":"LogicalVariableIndex\n\nA type for storing the index of a LogicalVariable.\n\nFields\n\nvalue::Int64: The index value.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.LogicalVariableRef","page":"API","title":"DisjunctiveProgramming.LogicalVariableRef","text":"LogicalVariableRef\n\nA type for looking up logical variables.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming._MOIAtLeast","page":"API","title":"DisjunctiveProgramming._MOIAtLeast","text":"_MOIAtLeast <: _MOI.AbstractVectorSet\n\nMOI level set for AtLeast constraints, see AtLeast for recommended syntax.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming._MOIAtMost","page":"API","title":"DisjunctiveProgramming._MOIAtMost","text":"_MOIAtMost <: _MOI.AbstractVectorSet\n\nMOI level set for AtMost constraints, see AtMost for recommended syntax.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming._MOIExactly","page":"API","title":"DisjunctiveProgramming._MOIExactly","text":"_MOIExactly <: _MOI.AbstractVectorSet\n\nMOI level set for Exactly constraints, see Exactly for recommended syntax.\n\n\n\n\n\n","category":"type"},{"location":"#DisjunctiveProgramming.jl","page":"Home","title":"DisjunctiveProgramming.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Generalized Disjunctive Programming (GDP) extension to JuMP, based on the GDP modeling paradigm described in Perez and Grossmann, 2023.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: codecov) (Image: Docs) (Image: Docs)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"DisjunctiveProgramming\")","category":"page"},{"location":"#Model","page":"Home","title":"Model","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A generalized disjunctive programming (GDP) model is created using GDPModel(), where the optimizer can be passed at model creation, along with other keyword arguments supported by JuMP Models. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DisjunctiveProgramming\nusing HiGHS\n\nmodel = GDPModel(HiGHS.Optimizer)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A GDPModel is a JuMP Model with a GDPData field in the model's .ext dictionary, which stores the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Logical Variables: Indicator variables used for the various disjuncts involved in the model's disjunctions.\nLogical Constraints: Selector (cardinality) or proposition (Boolean) constraints describing the relationships between the logical variables.\nDisjunct Constraints: Constraints associated with each disjunct in the model.\nDisjunctions: Disjunction constraints.\nSolution Method: The reformulation technique or solution method. Currently supported methods include Big-M, Hull, and Indicator Constraints.\nReformulation Variables: List of JuMP variables created when reformulating a GDP model into a MIP model.\nReformulation Constraints: List of constraints created when reformulating a GDP model into a MIP model.\nReady to Optimize: Flag indicating if the model can be optimized.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additionally, the following mapping dictionaries are stored in GDPData:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Indicator to Binary: Maps the Logical variables to their respective reformulated Binary variables.\nIndicator to Constraints: Maps the Logical variables to the disjunct constraints associated with them.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A GDP Model's GDPData can be accessed via:","category":"page"},{"location":"","page":"Home","title":"Home","text":"data = gdp_data(model)","category":"page"},{"location":"#Logical-Variables","page":"Home","title":"Logical Variables","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Logical variables are JuMP AbstractVariables with two fields: fix_value and start_value. These can be optionally specified at variable creation. Logical variables are created with the @variable JuMP macro by adding the tag Logical as the last keyword argument. As with the regular @variable macro, variables can be named and indexed: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"@variable(model, Y[1:3], Logical)","category":"page"},{"location":"#Logical-Constraints","page":"Home","title":"Logical Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Two types of logical constraints are supported:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Selector or cardinality constraints: A subset of Logical variables is passed and Exactly, AtMost, or AtLeast n of these is allowed to be True. These constraints are specified with the func in set notation in MathOptInterface in a @constraint JuMP macro. It is not assumed that disjunctions have an Exactly(1) constraint enforced on their disjuncts upon creation. This constraint must be explicitly specified.\njulia  @constraint(model, [Y[1], Y[2]] in Exactly(1))\nProposition or Boolean constraints: These describe the relationships between Logical variables via Boolean algebra. Supported logical operators include:\n∨ or logical_or (OR, typed with \\vee + tab).\n∧ or logical_and (AND, typed with \\wedge + tab).\n¬ or logical_not (NOT, typed with \\neg + tab).\n⟹ of implies (Implication, typed with \\Longrightarrow + tab).\n⇔ or iff (double implication or equivalence, typed with \\Leftrightarrow + tab).\nThe @constraint JuMP macro is used to create these constraints with the IsTrue set:\njulia  @constraint(model, (Y[1] ⟹ Y[2]) in IsTrue())\nNote: The parenthesis in the example above around the implication clause are only required when the parent logical operator is ⟹ or ⇔ to avoid parsing errors.\nLogical propositions can be reformulated to IP constraints by automatic reformulation to Conjunctive Normal Form.","category":"page"},{"location":"#Disjunctions","page":"Home","title":"Disjunctions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Disjunctions are built by first defining the constraints associated with each disjunct. This is done via the @constraint JuMP macro with the extra Disjunct tag specifying the Logical variable associated with the constraint:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@variable(model, x)\n@constraint(model, x ≤ 100, Disjunct(Y[1]))\n@constraint(model, x ≥ 200, Disjunct(Y[2]))","category":"page"},{"location":"","page":"Home","title":"Home","text":"After all disjunct constraints associated with a disjunction have been defined, the disjunction is created with the @disjunction macro, where the disjunction is defined as a Vector of Logical variables associated with each disjunct:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@disjunction(model, [Y[1], Y[2]])","category":"page"},{"location":"","page":"Home","title":"Home","text":"Disjunctions can be nested by passing an additional Disjunct tag. The Logical variable in the Disjunct tag specifies which disjunct, the nested disjunction belongs to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@disjunction(model, Y[1:2], Disjunct(Y[3]))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Empty disjuncts are supported in GDP models. When used, the only constraints enforced on the model when the empty disjunct is selected are the global constraints and any other disjunction constraints defined.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For convenience, the Exactly(1) selector constraint is added by default when adding a disjunction to the model. In other words, @disjunction(model, Y) will add the disjunction and automatically add the logical constraint Y in Exactly(1). For nested disjunctions, the appropriate Exactly constraint is added (e.g., @constraint(model, Y[1:2] in Exactly(Y[3]))) to indicate that Exactly 1 logical variable in Y[1:2] is set to true when Y[3] is true, and both variables in Y[1:2] are set to false when Y[3] is false, meaning the parent disjunct is not selected. Adding the Exactly selector constraint by default can be disabled by setting the keyword argument exactly1 to false in the @disjunction macro.","category":"page"},{"location":"#MIP-Reformulations","page":"Home","title":"MIP Reformulations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following reformulation methods are currently supported:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Big-M: The BigM struct is created with the following optional arguments:\nvalue: Big-M value to use. Default: 1e9. Big-M values are currently global to the model. Constraint specific Big-M values can be supported in future releases.\ntighten: Boolean indicating if tightening the Big-M value should be attempted (currently supported only for linear disjunct constraints when variable bounds have been set or specified in the variable_bounds field). Default: true.\nvariable_bounds: Dictionary specifying the lower and upper bounds for each VariableRef (e.g., Dict(x => (lb, ub))). Default: populate when calling the reformulation method.\nHull: The Hull struct is created with the following optional arguments:\nvalue: ϵ value to use when reformulating quadratic or nonlinear constraints via the perspective function proposed by Furman, et al. [2020]. Default: 1e-6. ϵ values are currently global to the model. Constraint specific tolerances can be supported in future releases.\nvariable_bounds: Dictionary specifying the lower and upper bounds for each VariableRef (e.g., Dict(x => (lb, ub))). Default: populate when calling the reformulation method.\nIndicator: This method reformulates each disjunct constraint into an indicator constraint with the Boolean reformulation counterpart of the Logical variable used to define the disjunct constraint.","category":"page"},{"location":"#Release-Notes","page":"Home","title":"Release Notes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Prior to v0.4.0, the package did not leverage the JuMP extension capabilities and was not as robust. For these earlier releases, refer to Perez, Joshi, and Grossmann, 2023 and the following JuliaCon 2022 Talk.","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The example below is from the Cornell University Computational Optimization Open Textbook.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DisjunctiveProgramming\nusing HiGHS\n\nm = GDPModel(HiGHS.Optimizer)\n@variable(m, 0 ≤ x[1:2] ≤ 20)\n@variable(m, Y[1:2], Logical)\n@constraint(m, [i = 1:2], [2,5][i] ≤ x[i] ≤ [6,9][i], Disjunct(Y[1]))\n@constraint(m, [i = 1:2], [8,10][i] ≤ x[i] ≤ [11,15][i], Disjunct(Y[2]))\n@disjunction(m, Y)\n@objective(m, Max, sum(x))\nprint(m)\n# Max x[1] + x[2]\n# Subject to\n#  x[1] ≥ 0\n#  x[2] ≥ 0\n#  x[1] ≤ 20\n#  x[2] ≤ 20\n\n##\noptimize!(m, method = BigM(100, false)) #specify M value and disable M-tightening\nprint(m)\n# Max x[1] + x[2]\n# Subject to\n#  Y[1] + Y[2] = 1\n#  x[1] - 100 Y[1] ≥ -98\n#  x[2] - 100 Y[1] ≥ -95\n#  x[1] - 100 Y[2] ≥ -92\n#  x[2] - 100 Y[2] ≥ -90\n#  x[1] + 100 Y[1] ≤ 106\n#  x[2] + 100 Y[1] ≤ 109\n#  x[1] + 100 Y[2] ≤ 111\n#  x[2] + 100 Y[2] ≤ 115\n#  x[1] ≥ 0\n#  x[2] ≥ 0\n#  x[1] ≤ 20\n#  x[2] ≤ 20\n#  Y[1] binary\n#  Y[2] binary\n\n##\noptimize!(m, method = Hull())\nprint(m)\n# Max x[1] + x[2]\n# Subject to\n#  -x[2] + x[2]_Y[1] + x[2]_Y[2] = 0\n#  -x[1] + x[1]_Y[1] + x[1]_Y[2] = 0\n#  Y[1] + Y[2] = 1\n#  -2 Y[1] + x[1]_Y[1] ≥ 0\n#  -5 Y[1] + x[2]_Y[1] ≥ 0\n#  -8 Y[2] + x[1]_Y[2] ≥ 0\n#  -10 Y[2] + x[2]_Y[2] ≥ 0\n#  x[2]_Y[1]_lower_bound : -x[2]_Y[1] ≤ 0\n#  x[2]_Y[1]_upper_bound : -20 Y[1] + x[2]_Y[1] ≤ 0\n#  x[1]_Y[1]_lower_bound : -x[1]_Y[1] ≤ 0\n#  x[1]_Y[1]_upper_bound : -20 Y[1] + x[1]_Y[1] ≤ 0\n#  x[2]_Y[2]_lower_bound : -x[2]_Y[2] ≤ 0\n#  x[2]_Y[2]_upper_bound : -20 Y[2] + x[2]_Y[2] ≤ 0\n#  x[1]_Y[2]_lower_bound : -x[1]_Y[2] ≤ 0\n#  x[1]_Y[2]_upper_bound : -20 Y[2] + x[1]_Y[2] ≤ 0\n#  -6 Y[1] + x[1]_Y[1] ≤ 0\n#  -9 Y[1] + x[2]_Y[1] ≤ 0\n#  -11 Y[2] + x[1]_Y[2] ≤ 0\n#  -15 Y[2] + x[2]_Y[2] ≤ 0\n#  x[1] ≥ 0\n#  x[2] ≥ 0\n#  x[2]_Y[1] ≥ 0\n#  x[1]_Y[1] ≥ 0\n#  x[2]_Y[2] ≥ 0\n#  x[1]_Y[2] ≥ 0\n#  x[1] ≤ 20\n#  x[2] ≤ 20\n#  x[2]_Y[1] ≤ 20\n#  x[1]_Y[1] ≤ 20\n#  x[2]_Y[2] ≤ 20\n#  x[1]_Y[2] ≤ 20\n#  Y[1] binary\n#  Y[2] binary","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DisjunctiveProgramming is being actively developed and suggestions or other forms of contribution are encouraged. There are many ways to contribute to this package. Feel free to create an issue to address questions or provide feedback.","category":"page"}]
}
