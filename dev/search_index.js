var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [DisjunctiveProgramming]\nOrder   = [:macro, :function, :type]","category":"page"},{"location":"api/#DisjunctiveProgramming.@disjunction-Tuple","page":"API","title":"DisjunctiveProgramming.@disjunction","text":"@disjunction(model, expr, kw_args...)\n\nAdd a disjunction described by the expression expr,  which must be a Vector of LogicalVariableRefs.\n\n@disjunction(model, ref[i=..., j=..., ...], expr, kw_args...)\n\nAdd a group of disjunction described by the expression expr parameterized by i, j, ..., which must be a Vector of LogicalVariableRefs. \n\nIn both of the above calls, a Disjunct tag can be added to create  nested disjunctions.\n\nThe recognized keyword arguments in kw_args are the following:\n\nbase_name: Sets the name prefix used to generate constraint names.    It corresponds to the constraint name for scalar constraints, otherwise,    the constraint names are set to base_name[...] for each index ...        of the axes axes.\ncontainer: Specify the container type.\nexactly1: Specify a Bool whether a constraint should be added to   only allow selecting one disjunct in the disjunction.\n\nTo create disjunctions without macros, see disjunction.\n\n\n\n\n\n","category":"macro"},{"location":"api/#DisjunctiveProgramming.@disjunctions-Tuple{Any, Any}","page":"API","title":"DisjunctiveProgramming.@disjunctions","text":"@disjunctions(model, args...)\n\nAdds groups of disjunctions at once, in the same fashion as the @disjunction macro.\n\nThe model must be the first argument, and multiple disjunctions can be added on multiple  lines wrapped in a begin ... end block.\n\nThe macro returns a tuple containing the disjunctions that were defined.\n\nExample\n\njulia model = GDPModel(); @variable(model, w); @variable(model, x); @variable(model, Y[1:4], LogicalVariable); @constraint(model, [i=1:2], w == i, Disjunct(Y[i])); @constraint(model, [i=3:4], x == i, Disjunct(Y[i])); @disjunctions(model, begin     [Y[1], Y[2]]     [Y[3], Y[4]] end);`\n\n\n\n\n\n","category":"macro"},{"location":"api/#DisjunctiveProgramming.binary_variable-Tuple{LogicalVariableRef}","page":"API","title":"DisjunctiveProgramming.binary_variable","text":"binary_variable(vref::LogicalVariableRef)::JuMP.AbstractVariableRef\n\nReturns the underlying binary variable for the logical variable vref which  is used in the reformulated model. This is helpful to embed logical variables  in algebraic constraints.\n\n\n\n\n\n","category":"method"},{"location":"api/#DisjunctiveProgramming.disjunction","page":"API","title":"DisjunctiveProgramming.disjunction","text":"disjunction(\n    model::JuMP.AbstractModel,\n    disjunct_indicators::Vector{LogicalVariableRef},\n    [nested_tag::Disjunct],\n    [name::String = \"\"];\n    [exactly1::Bool = true]\n)\n\nCreate a disjunction comprised of disjuncts with indicator variables disjunct_indicators and add it to model. For nested disjunctions, the nested_tag is required to indicate which disjunct it will be part of in the parent disjunction. By default, exactly1 adds a constraint of the form @constraint(model, disjunct_indicators in Exactly(1)) only allowing one of the disjuncts to be selected; this is required for certain reformulations like Hull. For nested disjunctions, exactly1 creates a constraint of the form @constraint(model, disjunct_indicators in Exactly(nested_tag.indicator)). To conveniently generate many disjunctions at once, see @disjunction and @disjunctions.\n\n\n\n\n\n","category":"function"},{"location":"api/#DisjunctiveProgramming.gdp_data-Tuple{AbstractModel}","page":"API","title":"DisjunctiveProgramming.gdp_data","text":"gdp_data(model::JuMP.AbstractModel)::GDPData\n\nExtract the GDPData from a GDPModel.\n\n\n\n\n\n","category":"method"},{"location":"api/#DisjunctiveProgramming.is_gdp_model-Tuple{AbstractModel}","page":"API","title":"DisjunctiveProgramming.is_gdp_model","text":"is_gdp_model(model::JuMP.AbstractModel)::Bool\n\nReturn if model was created via the GDPModel constructor.\n\n\n\n\n\n","category":"method"},{"location":"api/#DisjunctiveProgramming.make_disaggregated_variable-Tuple{GenericModel, GenericVariableRef, Any, Any, Any}","page":"API","title":"DisjunctiveProgramming.make_disaggregated_variable","text":"make_disaggregated_variable(\n    model::JuMP.AbstractModel, \n    vref::JuMP.AbstractVariableRef, \n    name::String, \n    lower_bound::Number, \n    upper_bound::Number\n    )::JuMP.AbstractVariableRef\n\nCreates and adds a variable to model with name name and bounds lower_bound  and upper_bound based on the original variable vref. This is used to  create dissagregated variables needed for the Hull reformulation. This is implemented for model::JuMP.GenericModel and  vref::JuMP.GenericVariableRef, but it serves as an extension point for  interfaces with other model/variable reference types. This also requires  the implementation of requires_disaggregation.\n\n\n\n\n\n","category":"method"},{"location":"api/#DisjunctiveProgramming.reformulate_disjunct_constraint-Tuple{AbstractModel, Disjunction, AbstractVariableRef, AbstractReformulationMethod}","page":"API","title":"DisjunctiveProgramming.reformulate_disjunct_constraint","text":"reformulate_disjunct_constraint(\n    model::JuMP.AbstractModel,  \n    con::JuMP.AbstractConstraint, \n    bvref::JuMP.AbstractVariableRef,\n    method::AbstractReformulationMethod\n)\n\nExtension point for reformulation method method to reformulate disjunction constraint con over each  constraint. If method needs to specify how to reformulate the entire disjunction, see  reformulate_disjunction.\n\n\n\n\n\n","category":"method"},{"location":"api/#DisjunctiveProgramming.reformulate_disjunction-Tuple{AbstractModel, Disjunction, AbstractReformulationMethod}","page":"API","title":"DisjunctiveProgramming.reformulate_disjunction","text":"reformulate_disjunction(\n    model::JuMP.AbstractModel, \n    disj::Disjunction,\n    method::AbstractReformulationMethod\n) where {T<:Disjunction}\n\nReformulate a disjunction using the specified method. Current reformulation methods include BigM, Hull, and Indicator. This method can be extended for other reformulation techniques.\n\nThe disj field is the ConstraintData object for the disjunction, stored in the  disjunctions field of the GDPData object.\n\n\n\n\n\n","category":"method"},{"location":"api/#DisjunctiveProgramming.reformulate_model","page":"API","title":"DisjunctiveProgramming.reformulate_model","text":"reformulate_model(model::JuMP.AbstractModel, method::AbstractSolutionMethod = BigM())\n\nReformulate a GDPModel using the specified method. Prior to reformulation, all previous reformulation variables and constraints are deleted.\n\n\n\n\n\n","category":"function"},{"location":"api/#DisjunctiveProgramming.requires_disaggregation-Tuple{GenericVariableRef}","page":"API","title":"DisjunctiveProgramming.requires_disaggregation","text":"requires_disaggregation(vref::JuMP.AbstractVariableRef)::Bool\n\nReturn a Bool whether vref requires disaggregation for the Hull  reformulation. This is intended as an extension point for interfaces with  DisjunctiveProgramming that use variable reference types that are not  JuMP.GenericVariableRefs. Errors if vref is not a JuMP.GenericVariableRef. See also make_disaggregated_variable.\n\n\n\n\n\n","category":"method"},{"location":"api/#DisjunctiveProgramming.requires_exactly1-Tuple{AbstractReformulationMethod}","page":"API","title":"DisjunctiveProgramming.requires_exactly1","text":"requires_exactly1(method::AbstractReformulationMethod)\n\nReturn a Bool whether method requires that Exactly 1 disjunct be selected  as true for each disjunction. For new reformulation method types, this should be  extended to return true if such a constraint is required (defaults to false otherwise).\n\n\n\n\n\n","category":"method"},{"location":"api/#DisjunctiveProgramming.requires_variable_bound_info-Tuple{AbstractReformulationMethod}","page":"API","title":"DisjunctiveProgramming.requires_variable_bound_info","text":"requires_variable_bound_info(method::AbstractReformulationMethod)::Bool\n\nReturn a Bool whether method requires variable bound information accessed  via variable_bound_info. This should be extended for new  AbstractReformulationMethod methods if needed (defaults to false).  If a new method does require variable bound information, then  set_variable_bound_info should also be extended.\n\n\n\n\n\n","category":"method"},{"location":"api/#DisjunctiveProgramming.set_variable_bound_info","page":"API","title":"DisjunctiveProgramming.set_variable_bound_info","text":"set_variable_bound_info(vref, method::AbstractReformulationMethod)::Tuple{<:Number, <:Number}\n\nReturns a tuple of the form (lower_bound, upper_bound) which are the bound information needed by  method to reformulate disjunctions. This only needs to be implemented for methods where  requires_variable_bound_info(method) = true. These bounds can later be accessed via  variable_bound_info.\n\n\n\n\n\n","category":"function"},{"location":"api/#DisjunctiveProgramming.variable_bound_info-Tuple{AbstractVariableRef}","page":"API","title":"DisjunctiveProgramming.variable_bound_info","text":"variable_bound_info(vref::JuMP.AbstractVariableRef)::Tuple{<:Number, <:Number}\n\nReturns a tuple of the form (lower_bound, upper_bound) needed to implement reformulation  methods. Only works if requires_variable_bound_info is implemented.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.add_constraint","page":"API","title":"JuMP.add_constraint","text":"JuMP.add_constraint(\n    model::JuMP.AbstractModel,\n    con::_DisjunctConstraint,\n    name::String = \"\"\n)::DisjunctConstraintRef\n\nExtend JuMP.add_constraint to add a Disjunct to a GDPModel. The constraint is added to the GDPData in the .ext dictionary of the GDPModel.\n\n\n\n\n\n","category":"function"},{"location":"api/#JuMP.add_constraint-Union{Tuple{M}, Tuple{S}, Tuple{M, ScalarConstraint{GenericNonlinearExpr{LogicalVariableRef{M}}, S}}, Tuple{M, ScalarConstraint{GenericNonlinearExpr{LogicalVariableRef{M}}, S}, String}} where {S, M<:GenericModel}","page":"API","title":"JuMP.add_constraint","text":"function JuMP.add_constraint(\n    model::JuMP.GenericModel,\n    c::JuMP.ScalarConstraint{_LogicalExpr, MOI.EqualTo{Bool}},\n    name::String = \"\"\n)\n\nExtend JuMP.add_constraint to allow creating logical proposition constraints for a GDPModel with the @constraint macro. Users should define logical constraints via the syntax @constraint(model, logical_expr := true).\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.add_constraint-Union{Tuple{S}, Tuple{F}, Tuple{GenericModel, VectorConstraint{F, S}}, Tuple{GenericModel, VectorConstraint{F, S}, String}} where {F, S<:AbstractCardinalitySet}","page":"API","title":"JuMP.add_constraint","text":"function JuMP.add_constraint(\n    model::JuMP.GenericModel,\n    c::VectorConstraint{<:F, S},\n    name::String = \"\"\n) where {F <: Vector{<:LogicalVariableRef}, S <: AbstractCardinalitySet}\n\nExtend JuMP.add_constraint to allow creating logical cardinality constraints for a GDPModel with the @constraint macro.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.add_variable","page":"API","title":"JuMP.add_variable","text":"JuMP.add_variable(model::JuMP.Model, v::LogicalVariable, \n                  name::String = \"\")::LogicalVariableRef\n\nExtend JuMP.add_variable for LogicalVariables. This  helps enable @variable(model, [var_expr], Logical).\n\n\n\n\n\n","category":"function"},{"location":"api/#JuMP.build_constraint-Tuple{Function, Any, MathOptInterface.AbstractScalarSet, Disjunct}","page":"API","title":"JuMP.build_constraint","text":"JuMP.build_constraint(\n    _error::Function,\n    func,\n    set::_MOI.AbstractScalarSet,\n    tag::Disjunct\n)::_DisjunctConstraint\n\nExtend JuMP.build_constraint to add constraints to disjuncts. This in combination with JuMP.add_constraint enables the use of @constraint(model, [name], constr_expr, tag), where tag is a Disjunct(::Type{LogicalVariableRef}). The user must specify the LogicalVariable to use as the indicator for the _DisjunctConstraint being created.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.build_constraint-Tuple{Function, Any, MathOptInterface.Nonnegatives, Disjunct}","page":"API","title":"JuMP.build_constraint","text":"JuMP.build_constraint(\n    _error::Function,\n    func,\n    set::MathOptInterface.Nonnegatives,\n    tag::Disjunct\n)::_DisjunctConstraint\n\nExtend JuMP.build_constraint to add VectorConstraints to disjuncts.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.build_constraint-Tuple{Function, Any, MathOptInterface.Nonpositives, Disjunct}","page":"API","title":"JuMP.build_constraint","text":"JuMP.build_constraint(\n    _error::Function,\n    func,\n    set::MathOptInterface.Nonpositives,\n    tag::Disjunct\n)::_DisjunctConstraint\n\nExtend JuMP.build_constraint to add VectorConstraints to disjuncts.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.build_constraint-Tuple{Function, Any, MathOptInterface.Zeros, Disjunct}","page":"API","title":"JuMP.build_constraint","text":"JuMP.build_constraint(\n    _error::Function,\n    func,\n    set::MathOptInterface.Zeros,\n    tag::Disjunct\n)::_DisjunctConstraint\n\nExtend JuMP.build_constraint to add VectorConstraints to disjuncts.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.build_constraint-Tuple{Function, Any, Nonnegatives, Disjunct}","page":"API","title":"JuMP.build_constraint","text":"JuMP.build_constraint(\n    _error::Function,\n    func,\n    set::Nonnegatives,\n    tag::Disjunct\n)::_DisjunctConstraint\n\nExtend JuMP.build_constraint to add VectorConstraints to disjuncts.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.build_constraint-Tuple{Function, Any, Nonpositives, Disjunct}","page":"API","title":"JuMP.build_constraint","text":"JuMP.build_constraint(\n    _error::Function,\n    func,\n    set::Nonpositives,\n    tag::Disjunct\n)::_DisjunctConstraint\n\nExtend JuMP.build_constraint to add VectorConstraints to disjuncts.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.build_constraint-Tuple{Function, Any, Zeros, Disjunct}","page":"API","title":"JuMP.build_constraint","text":"JuMP.build_constraint(\n    _error::Function,\n    func,\n    set::Zeros,\n    tag::Disjunct\n)::_DisjunctConstraint\n\nExtend JuMP.build_constraint to add VectorConstraints to disjuncts.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.build_constraint-Union{Tuple{S}, Tuple{T}, Tuple{Function, AbstractVector{T}, S}} where {T<:LogicalVariableRef, S<:Union{AtLeast{Int64}, AtMost{Int64}, Exactly{Int64}}}","page":"API","title":"JuMP.build_constraint","text":"function JuMP.build_constraint(\n    _error::Function,\n    func::AbstractVector{T},\n    set::S\n) where {T <: LogicalVariableRef, S <: Union{Exactly, AtLeast, AtMost}}\n\nExtend JuMP.build_constraint to add logical cardinality constraints to a GDPModel. This in combination with JuMP.add_constraint enables the use of @constraint(model, [name], logical_expr in set), where set can be either of the following cardinality sets: AtLeast(n), AtMost(n), or Exactly(n).\n\nExample\n\nTo select exactly 1 logical variable Y to be true, do (the same can be done with AtLeast(n) and AtMost(n)):\n\nusing DisjunctiveProgramming\nmodel = GDPModel();\n@variable(model, Y[i = 1:2], LogicalVariable);\n@constraint(model, [Y[1], Y[2]] in Exactly(1));\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.build_variable-Tuple{Function, VariableInfo, Type{Logical}}","page":"API","title":"JuMP.build_variable","text":"JuMP.build_variable(_error::Function, info::JuMP.VariableInfo, \n                    ::Union{Type{Logical}, Logical})\n\nExtend JuMP.build_variable to work with logical variables. This in  combination with JuMP.add_variable enables the use of  @variable(model, [var_expr], Logical).\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.constraint_object-Tuple{DisjunctConstraintRef}","page":"API","title":"JuMP.constraint_object","text":"JuMP.constraint_object(cref::DisjunctConstraintRef)\n\nReturn the underlying constraint data for the constraint     referenced by cref.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.constraint_object-Tuple{DisjunctionRef}","page":"API","title":"JuMP.constraint_object","text":"JuMP.constraint_object(cref::DisjunctionRef)\n\nReturn the underlying constraint data for the constraint     referenced by cref.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.constraint_object-Tuple{LogicalConstraintRef}","page":"API","title":"JuMP.constraint_object","text":"JuMP.constraint_object(cref::LogicalConstraintRef)\n\nReturn the underlying constraint data for the constraint     referenced by cref.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.delete-Tuple{AbstractModel, DisjunctConstraintRef}","page":"API","title":"JuMP.delete","text":"JuMP.delete(model::JuMP.AbstractModel, cref::DisjunctConstraintRef)\n\nDelete a disjunct constraint from the GDP model.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.delete-Tuple{AbstractModel, DisjunctionRef}","page":"API","title":"JuMP.delete","text":"JuMP.delete(model::JuMP.AbstractModel, cref::DisjunctionRef)\n\nDelete a disjunction constraint from the GDP model.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.delete-Tuple{AbstractModel, LogicalConstraintRef}","page":"API","title":"JuMP.delete","text":"JuMP.delete(model::JuMP.AbstractModel, cref::LogicalConstraintRef)\n\nDelete a logical constraint from the GDP model.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.delete-Tuple{AbstractModel, LogicalVariableRef}","page":"API","title":"JuMP.delete","text":"JuMP.delete(model::JuMP.AbstractModel, vref::LogicalVariableRef)::Nothing\n\nDelete the logical variable associated with vref from the GDP model.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.fix-Tuple{LogicalVariableRef, Bool}","page":"API","title":"JuMP.fix","text":"JuMP.fix(vref::LogicalVariableRef, value::Bool)::Nothing\n\nFix a logical variable to a value. Update the fixing constraint if one exists, otherwise create a new one.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.fix_value-Tuple{LogicalVariableRef}","page":"API","title":"JuMP.fix_value","text":"JuMP.fix_value(vref::LogicalVariableRef)::Bool\n\nReturn the value to which a logical variable is fixed.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.index-Tuple{DisjunctConstraintRef}","page":"API","title":"JuMP.index","text":"JuMP.index(cref::DisjunctConstraintRef)\n\nReturn the index constraint associated with cref.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.index-Tuple{DisjunctionRef}","page":"API","title":"JuMP.index","text":"JuMP.index(cref::DisjunctionRef)\n\nReturn the index constraint associated with cref.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.index-Tuple{LogicalConstraintRef}","page":"API","title":"JuMP.index","text":"JuMP.index(cref::LogicalConstraintRef)\n\nReturn the index constraint associated with cref.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.index-Tuple{LogicalVariableRef}","page":"API","title":"JuMP.index","text":"JuMP.index(vref::LogicalVariableRef)::LogicalVariableIndex\n\nReturn the index of logical variable that associated with vref.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.is_fixed-Tuple{LogicalVariableRef}","page":"API","title":"JuMP.is_fixed","text":"JuMP.is_fixed(vref::LogicalVariableRef)::Bool\n\nReturn true if vref is a fixed variable. If     true, the fixed value can be queried with     fix_value.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.is_valid-Tuple{AbstractModel, DisjunctConstraintRef}","page":"API","title":"JuMP.is_valid","text":"JuMP.is_valid(model::JuMP.AbstractModel, cref::DisjunctConstraintRef)\n\nReturn true if cref refers to a valid constraint in the GDP model.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.is_valid-Tuple{AbstractModel, DisjunctionRef}","page":"API","title":"JuMP.is_valid","text":"JuMP.is_valid(model::JuMP.AbstractModel, cref::DisjunctionRef)\n\nReturn true if cref refers to a valid constraint in the GDP model.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.is_valid-Tuple{AbstractModel, LogicalConstraintRef}","page":"API","title":"JuMP.is_valid","text":"JuMP.is_valid(model::JuMP.AbstractModel, cref::LogicalConstraintRef)\n\nReturn true if cref refers to a valid constraint in the GDP model.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.is_valid-Tuple{AbstractModel, LogicalVariableRef}","page":"API","title":"JuMP.is_valid","text":"JuMP.is_valid(model::JuMP.AbstractModel, vref::LogicalVariableRef)::Bool\n\nReturn true if vref refers to a valid logical variable in GDP model.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.isequal_canonical-Tuple{LogicalVariableRef, LogicalVariableRef}","page":"API","title":"JuMP.isequal_canonical","text":"JuMP.isequal_canonical(v::LogicalVariableRef, w::LogicalVariableRef)::Bool\n\nReturn true if v and w refer to the same logical variable in the same GDP model.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.name-Tuple{DisjunctConstraintRef}","page":"API","title":"JuMP.name","text":"JuMP.name(cref::DisjunctConstraintRef)\n\nGet a constraint's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.name-Tuple{DisjunctionRef}","page":"API","title":"JuMP.name","text":"JuMP.name(cref::DisjunctionRef)\n\nGet a constraint's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.name-Tuple{LogicalConstraintRef}","page":"API","title":"JuMP.name","text":"JuMP.name(cref::LogicalConstraintRef)\n\nGet a constraint's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.name-Tuple{LogicalVariableRef}","page":"API","title":"JuMP.name","text":"JuMP.name(vref::LogicalVariableRef)::String\n\nGet a logical variable's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.owner_model-Tuple{DisjunctConstraintRef}","page":"API","title":"JuMP.owner_model","text":"JuMP.owner_model(cref::DisjunctConstraintRef)\n\nReturn the model to which cref belongs.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.owner_model-Tuple{DisjunctionRef}","page":"API","title":"JuMP.owner_model","text":"JuMP.owner_model(cref::DisjunctionRef)\n\nReturn the model to which cref belongs.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.owner_model-Tuple{LogicalConstraintRef}","page":"API","title":"JuMP.owner_model","text":"JuMP.owner_model(cref::LogicalConstraintRef)\n\nReturn the model to which cref belongs.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.owner_model-Tuple{LogicalVariableRef}","page":"API","title":"JuMP.owner_model","text":"JuMP.owner_model(vref::LogicalVariableRef)::JuMP.AbstractModel\n\nReturn the GDP model to which vref belongs.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.set_name-Tuple{DisjunctConstraintRef, String}","page":"API","title":"JuMP.set_name","text":"JuMP.set_name(cref::DisjunctConstraintRef, name::String)\n\nSet a constraint's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.set_name-Tuple{DisjunctionRef, String}","page":"API","title":"JuMP.set_name","text":"JuMP.set_name(cref::DisjunctionRef, name::String)\n\nSet a constraint's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.set_name-Tuple{LogicalConstraintRef, String}","page":"API","title":"JuMP.set_name","text":"JuMP.set_name(cref::LogicalConstraintRef, name::String)\n\nSet a constraint's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.set_name-Tuple{LogicalVariableRef, String}","page":"API","title":"JuMP.set_name","text":"JuMP.set_name(vref::LogicalVariableRef, name::String)::Nothing\n\nSet a logical variable's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.set_start_value-Tuple{LogicalVariableRef, Union{Nothing, Bool}}","page":"API","title":"JuMP.set_start_value","text":"JuMP.set_start_value(vref::LogicalVariableRef, value::Union{Nothing, Bool})::Nothing\n\nSet the start value of the logical variable vref.\n\nPass nothing to unset the start value.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.start_value-Tuple{LogicalVariableRef}","page":"API","title":"JuMP.start_value","text":"JuMP.start_value(vref::LogicalVariableRef)::Bool\n\nReturn the start value of the logical variable vref.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.unfix-Tuple{LogicalVariableRef}","page":"API","title":"JuMP.unfix","text":"JuMP.unfix(vref::LogicalVariableRef)::Nothing\n\nDelete the fixed value of a logical variable.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuMP.value-Tuple{LogicalVariableRef}","page":"API","title":"JuMP.value","text":"JuMP.value(vref::LogicalVariableRef)::Bool\n\nReturns the optimized value of vref. This dispatches on  value(binary_variable(vref)) and then rounds to the closest  Bool value.\n\n\n\n\n\n","category":"method"},{"location":"api/#DisjunctiveProgramming.AbstractCardinalitySet","page":"API","title":"DisjunctiveProgramming.AbstractCardinalitySet","text":"AbstractCardinalitySet <: MOI.AbstractVectorSet\n\nAn abstract type for cardinality sets _MOIAtLeast, _MOIExactly, and _MOIAtMost.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.AbstractReformulationMethod","page":"API","title":"DisjunctiveProgramming.AbstractReformulationMethod","text":"AbstractReformulationMethod <: AbstractSolutionMethod\n\nAn abstract type for reformulation approaches used to solve GDPModels.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.AbstractSolutionMethod","page":"API","title":"DisjunctiveProgramming.AbstractSolutionMethod","text":"AbstractSolutionMethod\n\nAn abstract type for solution methods used to solve GDPModels.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.AtLeast","page":"API","title":"DisjunctiveProgramming.AtLeast","text":"AtLeast{T<:Union{Int,LogicalVariableRef}} <: JuMP.AbstractVectorSet\n\nConvenient alias for using _MOIAtLeast.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.AtMost","page":"API","title":"DisjunctiveProgramming.AtMost","text":"AtMost{T<:Union{Int,LogicalVariableRef}} <: JuMP.AbstractVectorSet\n\nConvenient alias for using _MOIAtMost.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.BigM","page":"API","title":"DisjunctiveProgramming.BigM","text":"BigM{T} <: AbstractReformulationMethod\n\nA type for using the big-M reformulation approach for disjunctive constraints.\n\nFields\n\nvalue::T: Big-M value (default = 1e9).\ntight::Bool: Attempt to tighten the Big-M value (default = true)?\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.ConstraintData","page":"API","title":"DisjunctiveProgramming.ConstraintData","text":"ConstraintData{C <: JuMP.AbstractConstraint}\n\nA type for storing constraint objects in GDPData and any meta-data  they possess.\n\nFields\n\nconstraint::C: The constraint.\nname::String: The name of the proposition.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.Disjunct","page":"API","title":"DisjunctiveProgramming.Disjunct","text":"Disjunct\n\nUsed as a tag for constraints that will be used in disjunctions. This is done via  the following syntax:\n\njulia> @constraint(model, [constr_expr], Disjunct)\n\njulia> @constraint(model, [constr_expr], Disjunct(lvref))\n\nwhere lvref is a LogicalVariableRef that will ultimately be associated  with the disjunct the constraint is added to. If no lvref is given, then one is  generated when the disjunction is created.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.DisjunctConstraintIndex","page":"API","title":"DisjunctiveProgramming.DisjunctConstraintIndex","text":"DisjunctConstraintIndex\n\nA type for storing the index of a Disjunct.\n\nFields\n\nvalue::Int64: The index value.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.DisjunctConstraintRef","page":"API","title":"DisjunctiveProgramming.DisjunctConstraintRef","text":"DisjunctConstraintRef{M <: JuMP.AbstractModel}\n\nA type for looking up disjunctive constraints.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.Disjunction","page":"API","title":"DisjunctiveProgramming.Disjunction","text":"Disjunction{M <: JuMP.AbstractModel} <: JuMP.AbstractConstraint\n\nA type for a disjunctive constraint that is comprised of a collection of  disjuncts of indicated by a unique LogicalVariableIndex.\n\nFields\n\nindicators::Vector{LogicalVariableref}: The references to the logical variables \n\n(indicators) that uniquely identify each disjunct in the disjunction.\n\nnested::Bool: Is this disjunction nested within another disjunction?\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.DisjunctionIndex","page":"API","title":"DisjunctiveProgramming.DisjunctionIndex","text":"DisjunctionIndex\n\nA type for storing the index of a Disjunction.\n\nFields\n\nvalue::Int64: The index value.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.DisjunctionRef","page":"API","title":"DisjunctiveProgramming.DisjunctionRef","text":"DisjunctionRef{M <: JuMP.AbstractModel}\n\nA type for looking up disjunctive constraints.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.Exactly","page":"API","title":"DisjunctiveProgramming.Exactly","text":"Exactly <: JuMP.AbstractVectorSet\n\nConvenient alias for using _MOIExactly.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.GDPData","page":"API","title":"DisjunctiveProgramming.GDPData","text":"GDPData{M <: JuMP.AbstractModel, V <: JuMP.AbstractVariableRef, CrefType, ValueType}\n\nThe core type for storing information in a GDPModel.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.GDPModel-Union{Tuple, Tuple{C}, Tuple{V}, Tuple{M}} where {M<:AbstractModel, V<:AbstractVariableRef, C}","page":"API","title":"DisjunctiveProgramming.GDPModel","text":"GDPModel([optimizer]; [kwargs...])::JuMP.Model\n\nGDPModel{T}([optimizer]; [kwargs...])::JuMP.GenericModel{T}\n\nGDPModel{M <: JuMP.AbstractModel, VrefType, CrefType}([optimizer], [args...]; [kwargs...])::M\n\nThe core model object for building general disjunction programming models.\n\n\n\n\n\n","category":"method"},{"location":"api/#DisjunctiveProgramming.Hull","page":"API","title":"DisjunctiveProgramming.Hull","text":"Hull{T} <: AbstractReformulationMethod\n\nA type for using the convex hull reformulation approach for disjunctive  constraints.\n\nFields\n\nvalue::T: epsilon value for nonlinear hull reformulations (default = 1e-6).\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.Indicator","page":"API","title":"DisjunctiveProgramming.Indicator","text":"Indicator <: AbstractReformulationMethod\n\nA type for using indicator constraint approach for linear disjunctive constraints.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.Logical","page":"API","title":"DisjunctiveProgramming.Logical","text":"Logical{T}\n\nTag for creating logical variables using @variable. Most often this will  be used to enable the syntax:\n\n@variable(model, var_expr, Logical, [kwargs...])\n\nwhich creates a LogicalVariable that will ultimately be  reformulated into a binary variable of the form:\n\n@variable(model, var_expr, Bin, [kwargs...])\n\nTo include a tag that is used to create the reformulated variables, the syntax  becomes:\n\n@variable(model, var_expr, Logical(MyTag()), [kwargs...])\n\nwhich creates a LogicalVariable that is associated with MyTag() such  that the reformulation binary variables are of the form:\n\n@variable(model, var_expr, Bin, MyTag(), [kwargs...])\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.LogicalConstraintIndex","page":"API","title":"DisjunctiveProgramming.LogicalConstraintIndex","text":"LogicalConstraintIndex\n\nA type for storing the index of a logical constraint.\n\nFields\n\nvalue::Int64: The index value.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.LogicalConstraintRef","page":"API","title":"DisjunctiveProgramming.LogicalConstraintRef","text":"LogicalConstraintRef{M <: JuMP.AbstractModel}\n\nA type for looking up logical constraints.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.LogicalVariable","page":"API","title":"DisjunctiveProgramming.LogicalVariable","text":"LogicalVariable <: JuMP.AbstractVariable\n\nA variable type the logical variables associated with disjuncts in a Disjunction.\n\nFields\n\nfix_value::Union{Nothing, Bool}: A fixed boolean value if there is one.\nstart_value::Union{Nothing, Bool}: An initial guess if there is one.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.LogicalVariableData","page":"API","title":"DisjunctiveProgramming.LogicalVariableData","text":"LogicalVariableData\n\nA type for storing LogicalVariables and any meta-data they  possess.\n\nFields\n\nvariable::LogicalVariable: The logical variable object.\nname::String: The name of the variable.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.LogicalVariableIndex","page":"API","title":"DisjunctiveProgramming.LogicalVariableIndex","text":"LogicalVariableIndex\n\nA type for storing the index of a LogicalVariable.\n\nFields\n\nvalue::Int64: The index value.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming.LogicalVariableRef","page":"API","title":"DisjunctiveProgramming.LogicalVariableRef","text":"LogicalVariableRef{M <: JuMP.AbstractModel}\n\nA type for looking up logical variables.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming._MOIAtLeast","page":"API","title":"DisjunctiveProgramming._MOIAtLeast","text":"_MOIAtLeast <: AbstractCardinalitySet\n\nMOI level set for AtLeast constraints, see AtLeast for recommended syntax.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming._MOIAtMost","page":"API","title":"DisjunctiveProgramming._MOIAtMost","text":"_MOIAtMost <: AbstractCardinalitySet\n\nMOI level set for AtMost constraints, see AtMost for recommended syntax.\n\n\n\n\n\n","category":"type"},{"location":"api/#DisjunctiveProgramming._MOIExactly","page":"API","title":"DisjunctiveProgramming._MOIExactly","text":"_MOIExactly <: AbstractCardinalitySet\n\nMOI level set for Exactly constraints, see Exactly for recommended syntax.\n\n\n\n\n\n","category":"type"},{"location":"#DisjunctiveProgramming.jl","page":"Home","title":"DisjunctiveProgramming.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Generalized Disjunctive Programming (GDP) extension to JuMP.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: logo)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: codecov) (Image: Docs) (Image: Docs)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"DisjunctiveProgramming\")","category":"page"},{"location":"#Reference","page":"Home","title":"Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The theory behind the GDP modeling paradigm is described in the following references:","category":"page"},{"location":"","page":"Home","title":"Home","text":"JuliaCon 2022 Proceedings\nPerez and Grossmann (2023)\nGeneralized Disjunctive Programming\nDisjunctive Inequalities","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: DOI)","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you use DisjunctiveProgramming.jl in your research, we would greatly appreciate your citing it.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{Perez2023,\n  title = {DisjunctiveProgramming.jl: Generalized Disjunctive Programming Models and Algorithms for JuMP},\n  author = {Hector D. Perez and Shivank Joshi and Ignacio E. Grossmann},\n  journal = {Proceedings of the JuliaCon Conferences},\n  year = {2023},\n  publisher = {The Open Journal},\n  volume = {1},\n  number = {1},\n  pages = {117}\n}","category":"page"},{"location":"#Model","page":"Home","title":"Model","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A generalized disjunctive programming (GDP) model is created using GDPModel, where the optimizer can be passed at model creation, along with other keyword arguments supported by JuMP Models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DisjunctiveProgramming\nusing HiGHS\n\nmodel = GDPModel(HiGHS.Optimizer)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A GDPModel is a JuMP Model with a GDPData field in the model's .ext dictionary, which stores the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Logical Variables: Indicator variables used for the various disjuncts involved in the model's disjunctions.\nLogical Constraints: Selector (cardinality) or proposition (Boolean) constraints describing the relationships between the logical variables.\nDisjunct Constraints: Constraints associated with each disjunct in the model.\nDisjunctions: Disjunction constraints.\nSolution Method: The reformulation technique or solution method. Currently, supported methods include Big-M, Hull, and Indicator Constraints.\nReformulation Variables: List of JuMP variables created when reformulating a GDP model into a MIP model.\nReformulation Constraints: List of constraints created when reformulating a GDP model into a MIP model.\nReady to Optimize: Flag indicating if the model can be optimized.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additionally, the following mapping dictionaries are stored in GDPData:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Indicator to Binary: Maps the Logical variables to their respective reformulated Binary variables.\nIndicator to Constraints: Maps the Logical variables to the disjunct constraints associated with them.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A GDP Model's GDPData can be accessed via:","category":"page"},{"location":"","page":"Home","title":"Home","text":"data = gdp_data(model)","category":"page"},{"location":"#Logical-Variables","page":"Home","title":"Logical Variables","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Logical variables are JuMP AbstractVariables with two fields: fix_value and start_value. These can be optionally specified at variable creation. Logical variables are created with the @variable JuMP macro by adding the tag Logical as the last keyword argument. As with the regular @variable macro, variables can be named and indexed:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@variable(model, Y[1:3], Logical)","category":"page"},{"location":"#Logical-Constraints","page":"Home","title":"Logical Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Two types of logical constraints are supported:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Selector or cardinality constraints: A subset of Logical variables is passed and Exactly, AtMost, or AtLeast n of these is allowed to be true. These constraints are specified with the func in set notation in MathOptInterface in a @constraint JuMP macro. It is not assumed that disjunctions have an Exactly(1) constraint enforced on their disjuncts upon creation. This constraint must be explicitly specified.\njulia  @constraint(model, [Y[1], Y[2]] in Exactly(1))\nProposition or Boolean constraints: These describe the relationships between Logical variables via Boolean algebra. Supported logical operators include:\n∨ or logical_or or || (OR, typed with \\vee + tab).\n∧ or logical_and or && (AND, typed with \\wedge + tab).\n¬ or logical_not (NOT, typed with \\neg + tab).\n⟹ of implies (Implication, typed with \\Longrightarrow + tab).\n⇔ or iff or == (double implication or equivalence, typed with \\Leftrightarrow + tab).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The @constraint JuMP macro is used to create these constraints with :=:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@constraint(model, Y[1] ⟹ Y[2] := true)","category":"page"},{"location":"","page":"Home","title":"Home","text":"DisjunctiveProgramming.jl will automatically reformulate Logical propositions to integer programming constraints by converting these expressions to Conjunctive Normal Form, and then to algebraic constraints.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Variable splatting is supported in the logical operator functions logical_or, logical_and, logical_not, implies, and iff such that","category":"page"},{"location":"","page":"Home","title":"Home","text":"@constraint(model, logical_and(Y...) := true)","category":"page"},{"location":"","page":"Home","title":"Home","text":"is equivalent to","category":"page"},{"location":"","page":"Home","title":"Home","text":"@constraint(model, Y[1] ∧ Y[2] := true)","category":"page"},{"location":"#Disjunctions","page":"Home","title":"Disjunctions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Disjunctions are built by first defining the constraints associated with each disjunct. This is done via the @constraint JuMP macro with the extra Disjunct tag specifying the Logical variable associated with the constraint:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@variable(model, x)\n@constraint(model, x ≤ 100, Disjunct(Y[1]))\n@constraint(model, x ≥ 200, Disjunct(Y[2]))","category":"page"},{"location":"","page":"Home","title":"Home","text":"After all disjunct constraints associated with a disjunction have been defined, the disjunction is created with the @disjunction macro, where the disjunction is defined as a Vector of Logical variables associated with each disjunct:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@disjunction(model, [Y[1], Y[2]])","category":"page"},{"location":"","page":"Home","title":"Home","text":"Disjunctions can be nested by passing an additional Disjunct tag. The Logical variable in the Disjunct tag specifies which disjunct, the nested disjunction belongs to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@disjunction(model, Y[1:2], Disjunct(Y[3]))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Empty disjuncts are supported in GDP models. When used, the only constraints enforced on the model when the empty disjunct is selected are the global constraints and any other disjunction constraints defined.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For convenience, the Exactly(1) selector constraint is added by default when adding a disjunction to the model. In other words, @disjunction(model, Y) will add the disjunction and automatically add the logical constraint Y in Exactly(1). For nested disjunctions, the appropriate Exactly constraint is added (e.g., @constraint(model, Y[1:2] in Exactly(Y[3]))) to indicate that Exactly 1 logical variable in Y[1:2] is set to true when Y[3] is true, and both variables in Y[1:2] are set to false when Y[3] is false, meaning the parent disjunct is not selected. Adding the Exactly selector constraint by default can be disabled by setting the keyword argument exactly1 to false in the @disjunction macro.","category":"page"},{"location":"#MIP-Reformulations","page":"Home","title":"MIP Reformulations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following reformulation methods are currently supported:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Big-M: The BigM struct is used.\nHull: The Hull struct is used.\nIndicator: This method reformulates each disjunct constraint into an indicator constraint with the Boolean reformulation counterpart of the Logical variable used to define the disjunct constraint. This is invoked with Indicator.","category":"page"},{"location":"#Release-Notes","page":"Home","title":"Release Notes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Prior to v0.4.0, the package did not leverage the JuMP extension capabilities and was not as robust. For these earlier releases, refer to Perez, Joshi, and Grossmann, 2023 and the following JuliaCon 2022 Talk.","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The example below is from the Cornell University Computational Optimization Open Textbook.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DisjunctiveProgramming\nusing HiGHS\n\nm = GDPModel(HiGHS.Optimizer)\n@variable(m, 0 ≤ x[1:2] ≤ 20)\n@variable(m, Y[1:2], Logical)\n@constraint(m, [i = 1:2], [2,5][i] ≤ x[i] ≤ [6,9][i], Disjunct(Y[1]))\n@constraint(m, [i = 1:2], [8,10][i] ≤ x[i] ≤ [11,15][i], Disjunct(Y[2]))\n@disjunction(m, Y)\n@objective(m, Max, sum(x))\nprint(m)\n# Max x[1] + x[2]\n# Subject to\n#  x[1] ≥ 0\n#  x[2] ≥ 0\n#  x[1] ≤ 20\n#  x[2] ≤ 20\n\n##\noptimize!(m, gdp_method = BigM(100, false)) #specify M value and disable M-tightening\nprint(m)\n# Max x[1] + x[2]\n# Subject to\n#  Y[1] + Y[2] = 1\n#  x[1] - 100 Y[1] ≥ -98\n#  x[2] - 100 Y[1] ≥ -95\n#  x[1] - 100 Y[2] ≥ -92\n#  x[2] - 100 Y[2] ≥ -90\n#  x[1] + 100 Y[1] ≤ 106\n#  x[2] + 100 Y[1] ≤ 109\n#  x[1] + 100 Y[2] ≤ 111\n#  x[2] + 100 Y[2] ≤ 115\n#  x[1] ≥ 0\n#  x[2] ≥ 0\n#  x[1] ≤ 20\n#  x[2] ≤ 20\n#  Y[1] binary\n#  Y[2] binary\n\n##\noptimize!(m, gdp_method = Hull())\nprint(m)\n# Max x[1] + x[2]\n# Subject to\n#  -x[2] + x[2]_Y[1] + x[2]_Y[2] = 0\n#  -x[1] + x[1]_Y[1] + x[1]_Y[2] = 0\n#  Y[1] + Y[2] = 1\n#  -2 Y[1] + x[1]_Y[1] ≥ 0\n#  -5 Y[1] + x[2]_Y[1] ≥ 0\n#  -8 Y[2] + x[1]_Y[2] ≥ 0\n#  -10 Y[2] + x[2]_Y[2] ≥ 0\n#  x[2]_Y[1]_lower_bound : -x[2]_Y[1] ≤ 0\n#  x[2]_Y[1]_upper_bound : -20 Y[1] + x[2]_Y[1] ≤ 0\n#  x[1]_Y[1]_lower_bound : -x[1]_Y[1] ≤ 0\n#  x[1]_Y[1]_upper_bound : -20 Y[1] + x[1]_Y[1] ≤ 0\n#  x[2]_Y[2]_lower_bound : -x[2]_Y[2] ≤ 0\n#  x[2]_Y[2]_upper_bound : -20 Y[2] + x[2]_Y[2] ≤ 0\n#  x[1]_Y[2]_lower_bound : -x[1]_Y[2] ≤ 0\n#  x[1]_Y[2]_upper_bound : -20 Y[2] + x[1]_Y[2] ≤ 0\n#  -6 Y[1] + x[1]_Y[1] ≤ 0\n#  -9 Y[1] + x[2]_Y[1] ≤ 0\n#  -11 Y[2] + x[1]_Y[2] ≤ 0\n#  -15 Y[2] + x[2]_Y[2] ≤ 0\n#  x[1] ≥ 0\n#  x[2] ≥ 0\n#  x[2]_Y[1] ≥ 0\n#  x[1]_Y[1] ≥ 0\n#  x[2]_Y[2] ≥ 0\n#  x[1]_Y[2] ≥ 0\n#  x[1] ≤ 20\n#  x[2] ≤ 20\n#  x[2]_Y[1] ≤ 20\n#  x[1]_Y[1] ≤ 20\n#  x[2]_Y[2] ≤ 20\n#  x[1]_Y[2] ≤ 20\n#  Y[1] binary\n#  Y[2] binary","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DisjunctiveProgramming is being actively developed and suggestions or other forms of contribution are encouraged. There are many ways to contribute to this package. Feel free to create an issue to address questions or provide feedback.","category":"page"}]
}
